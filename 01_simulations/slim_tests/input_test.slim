initialize() {

		
	// fitness-affecting mutations
	initializeMutationType("m1", 0.5, "f", 0.1); // p1 adaptive
	initializeMutationType("m2", 0.5, "f", 0.1); // p2 adaptive
    m1.mutationStackGroup = -1;
    m1.mutationStackPolicy = "l";
    m2.mutationStackGroup = -1;
    m2.mutationStackPolicy = "l";
    	
	// inversion mutations
	initializeMutationType("m3", 0.5, "f", 0.0); // the p1 inversion 
	initializeMutationType("m4", 0.5, "f", 0.0); // the p2 inversion 
    m3.mutationStackGroup = -1;
    m3.mutationStackPolicy = "l";
    m4.mutationStackGroup = -1;
    m4.mutationStackPolicy = "l";
    	
	// mutation rates for each class of locus (loci 0-1: fitness, locus 2: inversion)
	// formatted like: c(rate1,rate2), c(end1,end2)
	initializeMutationRate(c(0.000, 0), c(1, 2));

	// disallow substitution conversion  for inversion
	m1.convertToSubstitution = F;
	m2.convertToSubstitution = F;
	m3.convertToSubstitution = F;
	m4.convertToSubstitution = F;
	
	// colors for slimgui
	m1.color = "blue";
	m2.color = "red";
	m3.color = "blue"; 
	m4.color = "red";

	// genomic elements for the above mutation classes
	initializeGenomicElementType("g1", c(m1, m2), c(0.5, 0.5));
	initializeGenomicElement(g1, 0, 1);
	
	// g4 is the inversion "locus"
	initializeGenomicElementType("g4", c(m3, m4), c(0.5, 0.5));
	initializeGenomicElement(g4, 2, 2);
	
	// recombination
	// base rate also needs to be very high to see any recombination
	initializeRecombinationRate(1e-2);
	
	//	constant for all-way migration rate
	defineConstant("migration_rate", 0.00); 
	defineConstant("numpops", 2);
	defineConstant("pop_size", 50);
}

// divergent selection fitness callbacks

// m1 has negative s in p2
fitness(m1, p2) { 
	if (homozygous)
 		return 1.0 + (-1 * mut.selectionCoeff);
 	else
 		return 1.0 + (mut.mutationType.dominanceCoeff * -1 * mut.selectionCoeff);
}

// m2 has negative s in p1
fitness(m2, p1) { 
	if (homozygous)
 		return 1.0 + (-1 * mut.selectionCoeff);
 	else
 		return 1.0 + (mut.mutationType.dominanceCoeff * -1 * mut.selectionCoeff);
}


// model the inversion as a genome-wide recombination suppressor
recombination() {
	
	// if you are homozygous at the inversion locus, do nothing (allow recombination)
	// (this will need to be scripted to scale better)
	if (genome1.containsMarkerMutation(m3, 2) == genome2.containsMarkerMutation(m3, 2))
		return F;
	if (genome1.containsMarkerMutation(m4, 2) == genome2.containsMarkerMutation(m4, 2))
		return F;
	
	// otherwise, remove all proposed breakpoints (prevent recombination)
	breakpoints = -1;
	return T;
	
}

1 early(){
	
	// set up the populations

	// create initial populations
	sim.addSubpop("p1", pop_size); 
	sim.addSubpop("p2", pop_size);
	
	// migration rates
	// think about scaling for total number of migrants
	p1.setMigrationRates(p2, migration_rate);
	p2.setMigrationRates(p1, migration_rate);

}

1 late(){

	// add matching adaptive alleles & inverisons to every individual
	// (i.e. everything is fixed)
	p1.individuals.genomes.addNewDrawnMutation(m1, 0);
	p1.individuals.genomes.addNewDrawnMutation(m1, 1);
	p1.individuals.genomes.addNewDrawnMutation(m3, 2);
    // make half the pop the other mutant
    half = asInteger(pop_size);  // full pop size bc we want haploid genomes * 2
    half_pop = sample(p1.genomes, half);
    half_pop.addNewDrawnMutation(m2, 0);
    half_pop.addNewDrawnMutation(m2, 1);
    half_pop.addNewDrawnMutation(m4, 2);
    	
	p2.individuals.genomes.addNewDrawnMutation(m2, 0);
	p2.individuals.genomes.addNewDrawnMutation(m2, 1);
	p2.individuals.genomes.addNewDrawnMutation(m4, 2);
    // make half the pop the other mutant
    half = asInteger(pop_size);  // full pop size bc we want haploid genomes * 2
    half_pop = sample(p2.genomes, half);
    half_pop.addNewDrawnMutation(m1, 0);
    half_pop.addNewDrawnMutation(m1, 1);
    half_pop.addNewDrawnMutation(m3, 2);	
}

late(){
    if (sim.generation % 500 == 0 | sim.generation == 1){
    	cat("generation " + sim.generation + "\n");
	
		// Print out mutation frequency for inversion loci

		for (pop in sim.subpopulations){
			// print(sum(pop.genomes.countOfMutationsOfType(m3)));
			// print(pop.id);
			// m3 treated as colinear, m4 as inverted for printing
			total_colinear = sum(pop.genomes.countOfMutationsOfType(m3)); 
			total_inverted = sum(pop.genomes.countOfMutationsOfType(m4));
			inverted_freq = total_inverted/ (total_inverted + total_colinear);
			cat(pop.id + " " + inverted_freq + "\n");
		}
		// try to get haplotype frequencies



		for (i in 0:(numpops-1))
		{
			hap113freq = 0;
			hap114freq = 0;
			hap123freq = 0;
			hap124freq = 0;
			hap224freq = 0;
			hap223freq = 0;
			hap214freq = 0;
			hap213freq = 0;
			het_inv_freq = 0;
			hom_inv_freq = 0;
		
			inds = sim.subpopulations[i].individuals;

			for ( j in inds){
				if (j.genome1.containsMarkerMutation(m3, 2) & j.genome2.containsMarkerMutation(m4, 2))
					het_inv_freq = het_inv_freq + 1;
				if (j.genome1.containsMarkerMutation(m3, 2) & j.genome2.containsMarkerMutation(m3, 2))
					hom_inv_freq = hom_inv_freq + 1;
				if (j.genome1.containsMarkerMutation(m4, 2) & j.genome2.containsMarkerMutation(m4, 2))
					hom_inv_freq = hom_inv_freq + 1;
				if (j.genome1.containsMarkerMutation(m1, 0) & j.genome1.containsMarkerMutation(m1, 1) & j.genome1.containsMarkerMutation(m3, 2))
					hap113freq = hap113freq + 1;
				if (j.genome2.containsMarkerMutation(m1, 0) & j.genome2.containsMarkerMutation(m1, 1) & j.genome2.containsMarkerMutation(m3, 2))
					hap113freq = hap113freq + 1;
				if (j.genome1.containsMarkerMutation(m1, 0) & j.genome1.containsMarkerMutation(m1, 1) & j.genome1.containsMarkerMutation(m4, 2))
					hap114freq = hap114freq + 1;
				if (j.genome2.containsMarkerMutation(m1, 0) & j.genome2.containsMarkerMutation(m1, 1) & j.genome2.containsMarkerMutation(m4, 2))
					hap114freq = hap114freq + 1;
				if (j.genome1.containsMarkerMutation(m1, 0) & j.genome1.containsMarkerMutation(m2, 1) & j.genome1.containsMarkerMutation(m3, 2))
					hap123freq = hap123freq + 1;
				if (j.genome2.containsMarkerMutation(m1, 0) & j.genome2.containsMarkerMutation(m2, 1) & j.genome2.containsMarkerMutation(m3, 2))
					hap123freq = hap123freq + 1;
				if (j.genome1.containsMarkerMutation(m1, 0) & j.genome1.containsMarkerMutation(m2, 1) & j.genome1.containsMarkerMutation(m4, 2))
					hap124freq = hap124freq + 1;
				if (j.genome2.containsMarkerMutation(m1, 0) & j.genome2.containsMarkerMutation(m2, 1) & j.genome2.containsMarkerMutation(m4, 2))
					hap124freq = hap124freq + 1;
				if (j.genome1.containsMarkerMutation(m2, 0) & j.genome1.containsMarkerMutation(m2, 1) & j.genome1.containsMarkerMutation(m4, 2))
					hap224freq = hap224freq + 1;
				if (j.genome2.containsMarkerMutation(m2, 0) & j.genome2.containsMarkerMutation(m2, 1) & j.genome2.containsMarkerMutation(m4, 2))
					hap224freq = hap224freq + 1;
				if (j.genome1.containsMarkerMutation(m2, 0) & j.genome1.containsMarkerMutation(m2, 1) & j.genome1.containsMarkerMutation(m3, 2))
					hap223freq = hap223freq + 1;
				if (j.genome2.containsMarkerMutation(m2, 0) & j.genome2.containsMarkerMutation(m2, 1) & j.genome2.containsMarkerMutation(m3, 2))
					hap223freq = hap223freq + 1;
				if (j.genome1.containsMarkerMutation(m2, 0) & j.genome1.containsMarkerMutation(m1, 1) & j.genome1.containsMarkerMutation(m4, 2))
					hap214freq = hap214freq + 1;
				if (j.genome2.containsMarkerMutation(m2, 0) & j.genome2.containsMarkerMutation(m1, 1) & j.genome2.containsMarkerMutation(m4, 2))
					hap214freq = hap214freq + 1;
				if (j.genome1.containsMarkerMutation(m2, 0) & j.genome1.containsMarkerMutation(m1, 1) & j.genome1.containsMarkerMutation(m3, 2))
					hap213freq = hap213freq + 1;
				if (j.genome2.containsMarkerMutation(m2, 0) & j.genome2.containsMarkerMutation(m1, 1) & j.genome2.containsMarkerMutation(m3, 2))
					hap213freq = hap213freq + 1;
			}
			total_haps = hap113freq + hap114freq + hap123freq + hap124freq + hap224freq + hap223freq + hap214freq + hap213freq ;
		
			cat("pop" + i + " het inversion " + het_inv_freq/(hom_inv_freq + het_inv_freq) + "\n");
			cat("pop" + i + " hom inversion " + hom_inv_freq/(hom_inv_freq + het_inv_freq) + "\n");
			cat("pop" + i + " hap 113 " + hap113freq/total_haps + "\n");
			cat("pop" + i + " hap 114 " + hap114freq/total_haps + "\n");
			cat("pop" + i + " hap 123 " + hap123freq/total_haps + "\n");
			cat("pop" + i + " hap 124 " + hap124freq/total_haps + "\n");
			cat("pop" + i + " hap 224 " + hap224freq/total_haps + "\n");
			cat("pop" + i + " hap 223 " + hap223freq/total_haps + "\n");
			cat("pop" + i + " hap 214 " + hap214freq/total_haps + "\n");
			cat("pop" + i + " hap 213 " + hap213freq/total_haps + "\n");
		}
	}
}

	
//	for ( i in p1.individuals){
//		cat(i.genome1 + "\n");	
//	}	
//	for (i in 0:(numpops-1))
//	for (pop in sim.subpopulations){
//		for (ind in sim.subpopulations[pop].individuals){
//			cat(pop.id + " " + 1 + "\n");// + " " + ind + "\n");		
//			if (genome1.containsMarkerMutation(m4, 2) == genome2.containsMarkerMutation(m4, 2))
//				return F;
//		}
//	}


10000 late(){

	sim.outputFull("test_output.txt"); 
	sim.simulationFinished();

}


//containsMutations()
//mutationsOfType()

